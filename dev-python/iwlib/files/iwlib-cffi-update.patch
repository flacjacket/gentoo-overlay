diff --git a/.gitignore b/.gitignore
index 530741d..0eb52cf 100644
--- a/.gitignore
+++ b/.gitignore
@@ -1,5 +1,7 @@
 build/
 dist/
 iwlib.egg-info/
-*pyc
+*.pyc
 *.so
+*.c
+*.o
diff --git a/README.rst b/README.rst
index b5d1546..fe9e1c6 100644
--- a/README.rst
+++ b/README.rst
@@ -27,6 +27,12 @@ good to go.
 Change History
 --------------
 
+1.6
+    - Added support for Python 3 (via migration to CFFI)
+    - **API INCOMPATABILITY**: Dictionaries in 1.5 for Python 3 returned keys
+      of type `str`, but values of types `bytes`. They now always return type
+      `bytes`.
+
 1.5 (1st October 2014)
     - Added support for Python 3
 
diff --git a/iwlib/_iwlib_build.py b/iwlib/_iwlib_build.py
new file mode 100644
index 0000000..abea681
--- /dev/null
+++ b/iwlib/_iwlib_build.py
@@ -0,0 +1,212 @@
+# Copyright (C) 2009-2012 Red Hat, Inc.
+# Copyright (C) 2013-2014 Nathan Hoad.
+#
+# Interface with iwlib by Nathan Hoad <nathan@getoffmalawn.com>.
+#
+# This application is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License as published by the Free
+# Software Foundation; version 2.
+#
+# This application is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+# General Public License for more details.
+
+from cffi import FFI
+
+ffibuilder = FFI()
+
+
+funcs = """
+    double iw_freq2float(const iwfreq *in);
+    int iw_get_ext(int sock, char *interface, int flag, struct iwreq *req);
+    int iw_get_kernel_we_version();
+    int iw_get_range_info(int skfd, const char *ifname, iwrange *range);
+    int iw_get_stats(int skfd, const char *ifname, iwstats *stats, iwrange *range, int has_range);
+    int iw_scan(int sock, char *ifname, int we_version, wireless_scan_head *context);
+    int iw_set_ext(int sock, char *interface, int flag, struct iwreq *req);
+    int iw_sockets_open();
+    void iw_ether_ntop(const struct ether_addr *eth, char *buf);
+    void iw_print_bitrate(char *buffer, int buflen, int bitrate);
+    void iw_print_freq_value(char *buffer, int buflen, double freq);
+    void iw_sockets_close(int sock);
+    int ioctl(int fildes, unsigned long int request, ...);
+"""
+
+externs = """
+    extern const char * const iw_operation_mode[];
+"""
+
+defs = """
+    #define IW_ESSID_MAX_SIZE ...
+    #define SIOCSIWESSID ...
+    #define SIOCGIWESSID ...
+    #define SIOCSIWCOMMIT ...
+    #define SIOCGIWNAME ...
+    #define SIOCSIWNWID ...
+    #define SIOCGIWNWID ...
+    #define SIOCSIWFREQ ...
+    #define SIOCGIWFREQ ...
+    #define SIOCSIWMODE ...
+    #define SIOCGIWMODE ...
+    #define SIOCSIWSENS ...
+    #define SIOCGIWSENS ...
+    #define SIOCSIWRANGE ...
+    #define SIOCGIWRANGE ...
+    #define SIOCSIWPRIV ...
+    #define SIOCGIWPRIV ...
+    #define SIOCSIWSTATS ...
+    #define SIOCGIWSTATS ...
+    #define SIOCSIWSPY ...
+    #define SIOCGIWSPY ...
+    #define SIOCSIWTHRSPY ...
+    #define SIOCGIWTHRSPY ...
+    #define SIOCSIWAP ...
+    #define SIOCGIWAP ...
+    #define SIOCGIWAPLIST ...
+    #define SIOCSIWSCAN ...
+    #define SIOCGIWSCAN ...
+    #define SIOCSIWESSID ...
+    #define SIOCGIWESSID ...
+    #define SIOCSIWNICKN ...
+    #define SIOCGIWNICKN ...
+    #define SIOCSIWRATE ...
+    #define SIOCGIWRATE ...
+    #define SIOCSIWRTS ...
+    #define SIOCGIWRTS ...
+    #define SIOCSIWFRAG ...
+    #define SIOCGIWFRAG ...
+    #define SIOCSIWTXPOW ...
+    #define SIOCGIWTXPOW ...
+    #define SIOCSIWRETRY ...
+    #define SIOCGIWRETRY ...
+    #define SIOCSIWENCODE ...
+    #define SIOCGIWENCODE ...
+    #define SIOCSIWPOWER ...
+    #define SIOCGIWPOWER ...
+    #define SIOCSIWMODUL ...
+    #define SIOCGIWMODUL ...
+    #define SIOCSIWGENIE ...
+    #define SIOCGIWGENIE ...
+    #define SIOCSIWMLME ...
+    #define SIOCSIWAUTH ...
+    #define SIOCGIWAUTH ...
+    #define SIOCSIWENCODEEXT ...
+    #define SIOCGIWENCODEEXT ...
+    #define SIOCSIWPMKSA ...
+    #define SIOCIWFIRSTPRIV ...
+    #define SIOCIWLASTPRIV ...
+
+    #define IW_MODE_AUTO ...
+    #define IW_MODE_ADHOC ...
+    #define IW_MODE_INFRA ...
+    #define IW_MODE_MASTER ...
+    #define IW_MODE_REPEAT ...
+    #define IW_MODE_SECOND ...
+    #define IW_MODE_MONITOR ...
+
+    #define IW_NUM_OPER_MODE ...
+    #define IW_ENCODING_TOKEN_MAX ...
+    #define IW_ENCODE_DISABLED ...
+
+    #define IFNAMSIZ ...
+    #define SIOCGIFFLAGS ...
+"""
+
+structs = """
+    typedef struct sockaddr {
+        char sa_data[14];
+        ...;
+    } sockaddr;
+
+    typedef struct iw_param {
+        int value;
+        unsigned char disabled;
+        ...;
+    } iwparam;
+
+    struct wireless_config {
+        int has_mode;
+        int mode;
+        int essid_on;
+        char essid[];
+        ...;
+    };
+
+    typedef struct iw_statistics {
+        struct iw_quality qual;
+        ...;
+    } iwstats;
+
+    typedef struct wireless_scan {
+        struct wireless_scan *next;
+        int has_ap_addr;
+        int has_stats;
+        int has_maxbitrate;
+        iwparam maxbitrate;
+        iwstats stats;
+        struct wireless_config b;
+        sockaddr ap_addr;
+        ...;
+    } wireless_scan;
+
+    typedef struct wireless_scan_head {
+        wireless_scan *result;
+        int retry;
+    } wireless_scan_head;
+
+    struct iw_quality {
+        unsigned char qual;
+        unsigned char level;
+        unsigned char noise;
+        unsigned char updated;
+        ...;
+    };
+
+    struct iw_range {
+       unsigned char we_version_compiled;
+       struct iw_quality max_qual;
+       ...;
+    };
+
+    typedef struct iw_range iwrange;
+
+    struct iw_point {
+        void *pointer;
+        unsigned short length;
+        unsigned short flags;
+    };
+
+    typedef struct iw_freq {
+        int m;
+        short e;
+        unsigned char i;
+        unsigned char flags;
+    } iwfreq;
+
+    union iwreq_data {
+        struct iw_point essid;
+        struct iw_point data;
+        struct iw_freq freq;
+        sockaddr ap_addr;
+        int mode;
+        iwparam bitrate;
+        iwparam power;
+        iwparam nwid;
+        ...;
+    };
+
+    struct iwreq {
+        union iwreq_data u;
+        char ifr_name[...];
+        ...;
+    };
+"""
+
+ffibuilder.set_source("iwlib._iwlib", "#include <iwlib.h>", libraries=['iw'])
+ffibuilder.cdef(structs + externs + defs + funcs)
+
+iwlib = ffibuilder.verify("#include <iwlib.h>", libraries=['iw'])
+
+if __name__ == "__main__":
+        ffibuilder.compile()
diff --git a/iwlib/iwconfig.c b/iwlib/iwconfig.c
deleted file mode 100644
index 4d84aeb..0000000
--- a/iwlib/iwconfig.c
+++ /dev/null
@@ -1,301 +0,0 @@
-/*
- * Copyright (C) 2009-2012 Red Hat, Inc.
- * Copyright (C) 2013 Nathan Hoad.
- *
- * Interface with iwlib by Nathan Hoad <nathan@getoffmalawn.com>.
- *
- * This application is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License as published by the Free
- * Software Foundation; version 2.
- *
- * This application is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- */
-
-#include <Python.h>
-
-#include <errno.h>
-#include <unistd.h>
-#include <stdio.h>
-#include <string.h>
-#include <iwlib.h>
-#include <linux/sockios.h>
-
-#include "utils.h"
-
-/*------------------------------------------------------------------*/
-/*
- * Get wireless informations & config from the device driver
- * We will call all the classical wireless ioctl on the driver through
- * the socket to know what is supported and to get the settings...
- */
-static int
-get_info(int skfd, char *ifname, struct wireless_info *info)
-{
-    struct iwreq wrq;
-
-    memset((char *) info, 0, sizeof(struct wireless_info));
-
-    /* Get wireless name */
-    if(iw_get_ext(skfd, ifname, SIOCGIWNAME, &wrq) < 0) {
-        /* If no wireless name : no wireless extensions */
-        /* But let's check if the interface exists at all */
-        struct ifreq ifr;
-
-        strncpy(&ifr.ifr_name[0], ifname, IFNAMSIZ);
-        ifr.ifr_name[IFNAMSIZ-1] = 0;
-        if(ioctl(skfd, SIOCGIFFLAGS, &ifr) < 0)
-            return(-ENODEV);
-        else
-            return(-ENOTSUP);
-    } else {
-        strncpy(info->b.name, wrq.u.name, sizeof(info->b.name));
-        info->b.name[sizeof(info->b.name)-1] = 0;
-    }
-
-    /* Get ranges */
-    if(iw_get_range_info(skfd, ifname, &(info->range)) >= 0)
-        info->has_range = 1;
-
-    /* Get network ID */
-    if(iw_get_ext(skfd, ifname, SIOCGIWNWID, &wrq) >= 0) {
-        info->b.has_nwid = 1;
-        memcpy(&(info->b.nwid), &(wrq.u.nwid), sizeof(iwparam));
-    }
-
-    /* Get frequency / channel */
-    if(iw_get_ext(skfd, ifname, SIOCGIWFREQ, &wrq) >= 0) {
-        info->b.has_freq = 1;
-        info->b.freq = iw_freq2float(&(wrq.u.freq));
-    }
-
-    /* Get sensitivity */
-    if(iw_get_ext(skfd, ifname, SIOCGIWSENS, &wrq) >= 0) {
-        info->has_sens = 1;
-        memcpy(&(info->sens), &(wrq.u.sens), sizeof(iwparam));
-    }
-
-    /* Get encryption information */
-    wrq.u.data.pointer = (caddr_t) info->b.key;
-    wrq.u.data.length = IW_ENCODING_TOKEN_MAX;
-    wrq.u.data.flags = 0;
-    if(iw_get_ext(skfd, ifname, SIOCGIWENCODE, &wrq) >= 0) {
-        info->b.has_key = 1;
-        info->b.key_size = wrq.u.data.length;
-        info->b.key_flags = wrq.u.data.flags;
-    }
-
-    /* Get ESSID */
-    wrq.u.essid.pointer = (caddr_t) info->b.essid;
-    wrq.u.essid.length = IW_ESSID_MAX_SIZE;
-    wrq.u.essid.flags = 0;
-    if(iw_get_ext(skfd, ifname, SIOCGIWESSID, &wrq) >= 0) {
-        info->b.has_essid = 1;
-        info->b.essid_on = wrq.u.data.flags;
-    }
-
-    /* Get AP address */
-    if(iw_get_ext(skfd, ifname, SIOCGIWAP, &wrq) >= 0) {
-        info->has_ap_addr = 1;
-        memcpy(&(info->ap_addr), &(wrq.u.ap_addr), sizeof (sockaddr));
-    }
-
-    /* Get NickName */
-    wrq.u.essid.pointer = (caddr_t) info->nickname;
-    wrq.u.essid.length = IW_ESSID_MAX_SIZE;
-    wrq.u.essid.flags = 0;
-    if(iw_get_ext(skfd, ifname, SIOCGIWNICKN, &wrq) >= 0)
-        if(wrq.u.data.length > 1)
-            info->has_nickname = 1;
-
-    /* Get bit rate */
-    if(iw_get_ext(skfd, ifname, SIOCGIWRATE, &wrq) >= 0) {
-        info->has_bitrate = 1;
-        memcpy(&(info->bitrate), &(wrq.u.bitrate), sizeof(iwparam));
-    }
-
-    /* Get RTS threshold */
-    if(iw_get_ext(skfd, ifname, SIOCGIWRTS, &wrq) >= 0) {
-        info->has_rts = 1;
-        memcpy(&(info->rts), &(wrq.u.rts), sizeof(iwparam));
-    }
-
-    /* Get fragmentation threshold */
-    if(iw_get_ext(skfd, ifname, SIOCGIWFRAG, &wrq) >= 0) {
-        info->has_frag = 1;
-        memcpy(&(info->frag), &(wrq.u.frag), sizeof(iwparam));
-    }
-
-    /* Get operation mode */
-    if(iw_get_ext(skfd, ifname, SIOCGIWMODE, &wrq) >= 0) {
-        info->b.mode = wrq.u.mode;
-        if((info->b.mode < IW_NUM_OPER_MODE) && (info->b.mode >= 0))
-            info->b.has_mode = 1;
-    }
-
-    /* Get Power Management settings */
-    wrq.u.power.flags = 0;
-    if(iw_get_ext(skfd, ifname, SIOCGIWPOWER, &wrq) >= 0) {
-        info->has_power = 1;
-        memcpy(&(info->power), &(wrq.u.power), sizeof(iwparam));
-    }
-
-#if WIRELESS_EXT > 9
-    /* Get Transmit Power */
-    if(iw_get_ext(skfd, ifname, SIOCGIWTXPOW, &wrq) >= 0) {
-        info->has_txpower = 1;
-        memcpy(&(info->txpower), &(wrq.u.txpower), sizeof(iwparam));
-    }
-#endif
-
-#if WIRELESS_EXT > 10
-    /* Get retry limit/lifetime */
-    if(iw_get_ext(skfd, ifname, SIOCGIWRETRY, &wrq) >= 0) {
-        info->has_retry = 1;
-        memcpy(&(info->retry), &(wrq.u.retry), sizeof(iwparam));
-    }
-#endif  /* WIRELESS_EXT > 10 */
-
-    /* Get stats */
-    if(iw_get_stats(skfd, ifname, &(info->stats), &(info->range), info->has_range) >= 0) {
-        info->has_stats = 1;
-    }
-
-    return(0);
-}
-
-static PyObject *
-get_iwconfig (PyObject * self, PyObject * args)
-{
-    char *devname;
-    int skfd;
-    char buffer[1024];
-    int eno = 0;
-    struct wireless_info info;
-
-    if (!PyArg_ParseTuple(args, "s", &devname)) {
-        return NULL;
-    }
-
-    OPEN_IW(skfd);
-    eno = get_info(skfd, devname, &info);
-    iw_sockets_close(skfd);
-
-    if (eno < 0) {
-        eno = -eno;
-        sprintf(buffer, "get_info [Errno %d] %s", eno, strerror(eno));
-        PyErr_SetString(PyExc_IOError, buffer);
-        return NULL;
-    }
-
-    return wireless_info_to_PyDict(&info);
-}
-
-static PyObject *
-set_essid(PyObject *self, PyObject *args)
-{
-    char buffer[1024];
-    char essid_buf[IW_ESSID_MAX_SIZE+1];
-    const char *devname, *essid;
-    int essid_len;
-    int sock;
-    int we_kernel_version;
-    struct iwreq wrq;
-
-    if (!PyArg_ParseTuple(args, "ss", &devname, &essid)) {
-        return NULL;
-    }
-
-    essid_len = strlen(essid);
-
-    OPEN_IW(sock);
-
-    if((!strcasecmp(essid, "off")) || (!strcasecmp(essid, "any"))) {
-        wrq.u.essid.flags = 0;
-        essid_buf[0] = '\0';
-    } else if (!strcasecmp(essid, "on")) {
-        memset(essid_buf, '\0', sizeof(essid_buf));
-        wrq.u.essid.pointer = (caddr_t) essid_buf;
-        wrq.u.essid.length = IW_ESSID_MAX_SIZE + 1;
-        wrq.u.essid.flags = 0;
-        if(iw_get_ext(sock, devname, SIOCGIWESSID, &wrq) < 0) {
-            sprintf(buffer, "Error retrieving previous ESSID: %s",
-                strerror(errno));
-            goto error;
-        }
-        wrq.u.essid.flags = 1;
-    } else if(essid_len > IW_ESSID_MAX_SIZE) {
-        sprintf(buffer, "ESSID is longer than the maximum %d",
-            IW_ESSID_MAX_SIZE);
-        goto error;
-    } else {
-        memcpy(essid_buf, essid, essid_len);
-        essid_buf[essid_len] = '\0';
-        wrq.u.essid.flags = 1;
-    }
-
-    we_kernel_version = iw_get_kernel_we_version();
-
-    wrq.u.essid.pointer = (caddr_t) essid_buf;
-    wrq.u.essid.length = strlen(essid_buf);
-    if(we_kernel_version < 21)
-        wrq.u.essid.length++;
-
-    if(iw_set_ext(sock, devname, SIOCSIWESSID, &wrq) < 0) {
-        sprintf(buffer, "Couldn't set essid on device '%s': %s", devname,
-            strerror(errno));
-        goto error;
-    }
-
-    iw_sockets_close(sock);
-    Py_INCREF(Py_None);
-    return Py_None;
-
-    error:
-    iw_sockets_close(sock);
-    PyErr_SetString(PyExc_OSError, buffer);
-    return NULL;
-}
-
-static struct PyMethodDef PyEthModuleMethods[] = {
-    { "get_iwconfig",
-        (PyCFunction) get_iwconfig, METH_VARARGS,
-        "Retrieve the current configuration of an interface. \
-\n\nArguments:\
-\n  - device to work on (e.g. eth1, wlan0)." },
-    { "set_essid",
-        (PyCFunction) set_essid, METH_VARARGS,
-        "Set the ESSID of an interface. \
-\n\nArguments:\
-\n  - device to work on (e.g. eth1, wlan0).\
-\n  - essid to set device to." },
-    { NULL, NULL, 0, NULL } /* sentinel */
-};
-
-#if PY_MAJOR_VERSION >= 3 /* Python 3 */
-
-static struct PyModuleDef iwconfig = {
-        PyModuleDef_HEAD_INIT,
-        "iwconfig",
-        NULL, /* Documentation */
-        -1,
-        PyEthModuleMethods
-};
-
-PyMODINIT_FUNC
-PyInit_iwconfig(void) {
-    return PyModule_Create(&iwconfig);
-}
-
-#else /* Python2 */
-
-void
-initiwconfig(void) {
-    PyObject *m;
-    m = Py_InitModule("iwconfig", PyEthModuleMethods);
-    PyModule_GetDict(m);
-}
-
-#endif
diff --git a/iwlib/iwconfig.py b/iwlib/iwconfig.py
new file mode 100644
index 0000000..20a68d2
--- /dev/null
+++ b/iwlib/iwconfig.py
@@ -0,0 +1,165 @@
+# Copyright (C) 2009-2012 Red Hat, Inc.
+# Copyright (C) 2013-2014 Nathan Hoad.
+#
+# Interface with iwlib by Nathan Hoad <nathan@getoffmalawn.com>.
+#
+# This application is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License as published by the Free
+# Software Foundation; version 2.
+#
+# This application is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+# General Public License for more details.
+
+import os
+import errno
+
+from .utils import _parse_stats, _get_bytes, iwlib_socket
+from ._iwlib import ffi, lib as iwlib
+
+
+def get_iwconfig(interface):
+    """
+    Retrieve the current configuration of a given interface
+
+    Arguments:
+        interface - device to work on (e.g. eth1, wlan0).
+    """
+    with iwlib_socket() as sock:
+        return _get_iwconfig(interface, sock)
+
+
+def _get_iwconfig(interface, sock):
+    interface = _get_bytes(interface)
+
+    wrq = ffi.new('struct iwreq*')
+
+    iwconfig = {}
+
+    def get_ext(flag):
+        return iwlib.iw_get_ext(sock, interface, flag, wrq) >= 0
+
+    if not get_ext(iwlib.SIOCGIWNAME):
+        wrq.ifr_ifrn = interface[:iwlib.IFNAMSIZ-1]
+        wrq.ifr_ifrn[iwlib.IFNAMSIZ-1] = b'\0'
+
+        if iwlib.ioctl(sock, iwlib.SIOCGIFFLAGS, wrq) < 0:
+            err = errno.ENODEV
+        else:
+            err = errno.ENOTSUP
+
+        strerror = os.strerror(err)
+
+        raise OSError(err, "Could not get config for '%s': %s" % (interface.decode('utf8'), strerror))
+
+    if not get_ext(iwlib.SIOCGIWNWID):
+        if wrq.u.nwid.disabled:
+            iwconfig[b'NWID'] = b"Auto"
+        else:
+            iwconfig[b'NWID'] = ('%x' % (wrq.u.nwid.value)).encode('utf8')
+
+    buf = ffi.new('char []', 1024)
+
+    if get_ext(iwlib.SIOCGIWFREQ):
+        freq = iwlib.iw_freq2float(ffi.addressof(wrq.u.freq))
+        iwlib.iw_print_freq_value(buf, len(buf), freq)
+        iwconfig[b'Frequency'] = ffi.string(buf)
+
+    if get_ext(iwlib.SIOCGIWAP):
+        iwlib.iw_ether_ntop(ffi.cast('struct ether_addr *', wrq.u.ap_addr.sa_data), buf)
+        mode = wrq.u.mode
+        has_mode = 0 <= mode < iwlib.IW_NUM_OPER_MODE
+        if has_mode and mode == iwlib.IW_MODE_ADHOC:
+            iwconfig[b'Cell'] = ffi.string(buf)
+        else:
+            iwconfig[b'Access Point'] = ffi.string(buf)
+
+    if get_ext(iwlib.SIOCGIWRATE):
+        iwlib.iw_print_bitrate(buf, len(buf), wrq.u.bitrate.value)
+        iwconfig[b'BitRate'] = ffi.string(buf)
+
+    if get_ext(iwlib.SIOCGIWRATE):
+        iwlib.iw_print_bitrate(buf, len(buf), wrq.u.bitrate.value)
+        iwconfig[b'BitRate'] = ffi.string(buf)
+
+    buf = ffi.new('char []', 1024)
+    wrq.u.data.pointer = buf
+    wrq.u.data.length = iwlib.IW_ENCODING_TOKEN_MAX
+    wrq.u.data.flags = 0
+    if get_ext(iwlib.SIOCGIWENCODE):
+        flags = wrq.u.data.flags
+        key_size = wrq.u.data.length
+
+        if flags & iwlib.IW_ENCODE_DISABLED or not key_size:
+            iwconfig[b'Key'] = b'off'
+        else:
+            key = ffi.new('char []', 1024)
+            iwlib.iw_print_key(key, len(key), buf, key_size, flags)
+            iwconfig[b'Key'] = ffi.string(key)
+
+    essid = ffi.new('char []', iwlib.IW_ESSID_MAX_SIZE+1)
+    wrq.u.essid.pointer = essid
+    wrq.u.essid.length = iwlib.IW_ESSID_MAX_SIZE + 1
+    wrq.u.essid.flags = 0
+    if get_ext(iwlib.SIOCGIWESSID):
+        iwconfig[b'ESSID'] = ffi.string(ffi.cast('char *', (wrq.u.essid.pointer)))
+        wrq.u.essid.length = iwlib.IW_ESSID_MAX_SIZE + 1
+        wrq.u.essid.flags = 0
+
+    if get_ext(iwlib.SIOCGIWMODE):
+        mode = wrq.u.mode
+        has_mode = 0 <= mode < iwlib.IW_NUM_OPER_MODE
+        if has_mode:
+            iwconfig[b'Mode'] = ffi.string(iwlib.iw_operation_mode[mode])
+
+    stats = ffi.new('iwstats *')
+    range = ffi.new('iwrange *')
+
+    has_range = int(iwlib.iw_get_range_info(sock, interface, range) >= 0)
+    if iwlib.iw_get_stats(sock, interface, stats, range, has_range) >= 0:
+        iwconfig[b'stats'] = _parse_stats(stats)
+
+    return iwconfig
+
+
+def set_essid(interface, essid):
+    """
+    Set the ESSID of a given interface
+
+    Arguments:
+        interface - device to work on (e.g. eth1, wlan0).
+        essid - ESSID to set. Must be no longer than IW_ESSID_MAX_SIZE (typically 32 characters).
+
+    """
+    interface = _get_bytes(interface)
+    essid = _get_bytes(essid)
+
+    wrq = ffi.new('struct iwreq*')
+
+    with iwlib_socket() as sock:
+        if essid.lower() in (b'off', b'any'):
+            wrq.u.essid.flags = 0
+            essid = b''
+        elif essid.lower() == b'on':
+            buf = ffi.new('char []', iwlib.IW_ESSID_MAX_SIZE+1)
+            wrq.u.essid.pointer = buf
+            wrq.u.essid.length = iwlib.IW_ESSID_MAX_SIZE + 1
+            wrq.u.essid.flags = 0
+            if iwlib.iw_get_ext(sock, interface, iwlib.SIOCGIWESSID, wrq) < 0:
+                raise ValueError("Error retrieving previous ESSID: %s" % (os.strerror(ffi.errno)))
+            wrq.u.essid.flags = 1
+        elif len(essid) > iwlib.IW_ESSID_MAX_SIZE:
+            raise ValueError("ESSID '%s' is longer than the maximum %d" % (essid, iwlib.IW_ESSID_MAX_SIZE))
+        else:
+            wrq.u.essid.pointer = ffi.new_handle(essid)
+            wrq.u.essid.length = len(essid)
+            wrq.u.essid.flags = 1
+
+        if iwlib.iw_get_kernel_we_version() < 21:
+            wrq.u.essid.length += 1
+
+        if iwlib.iw_set_ext(sock, interface, iwlib.SIOCSIWESSID, wrq) < 0:
+            errno = ffi.errno
+            strerror = "Couldn't set essid on device '%s': %s" % (interface.decode('utf8'), os.strerror(errno))
+            raise OSError(errno, strerror)
diff --git a/iwlib/iwlist.c b/iwlib/iwlist.c
deleted file mode 100644
index ef4c28f..0000000
--- a/iwlib/iwlist.c
+++ /dev/null
@@ -1,123 +0,0 @@
-/*
- * Copyright (C) 2009-2012 Red Hat, Inc.
- * Copyright (C) 2013 Nathan Hoad.
- *
- * Interface with iwlib by Nathan Hoad <nathan@getoffmalawn.com>.
- *
- * This application is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License as published by the Free
- * Software Foundation; version 2.
- *
- * This application is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- */
-
-#include <Python.h>
-
-#include <errno.h>
-#include <unistd.h>
-#include <stdio.h>
-#include <string.h>
-#include <iwlib.h>
-#include <linux/sockios.h>
-#include <sys/time.h>
-
-#include "utils.h"
-
-static PyObject *
-scan(PyObject *self, PyObject *args)
-{
-    PyObject *dict, *list;
-    char *devname;
-    char buffer[1024];
-    int has_range;
-    int sock;
-    struct iw_range range;
-    struct wireless_scan *cur, *prev = NULL;
-    wireless_scan_head head;
-
-    if (!PyArg_ParseTuple(args, "s", &devname)) {
-        return NULL;
-    }
-
-    OPEN_IW(sock);
-
-    has_range = (iw_get_range_info(sock, devname, &range) >= 0);
-
-    if((!has_range) || (range.we_version_compiled < 14)) {
-        sprintf(buffer, "'%s' Interface doesn't support scanning", devname);
-        goto error;
-    }
-
-    if (iw_scan(sock, devname, range.we_version_compiled, &head) != 0) {
-        sprintf(buffer, "Error while scanning: %s", strerror(errno));
-        goto error;
-    }
-
-    if ((list = PyList_New(0)) == NULL) {
-        /* we can't goto error and wipe out a possible MemoryError. */
-        iw_sockets_close(sock);
-        return NULL;
-    };
-
-    cur = head.result;
-    while (cur != NULL) {
-        if ((dict = wireless_scan_to_PyDict(cur)) == NULL) {
-            iw_sockets_close(sock);
-            return list;
-        };
-
-        PyList_Append(list, dict);
-
-        prev = cur;
-        cur = cur->next;
-        free(prev);
-    }
-
-    iw_sockets_close(sock);
-    return list;
-
-    error:
-    iw_sockets_close(sock);
-    PyErr_SetString(PyExc_OSError, buffer);
-    return NULL;
-}
-
-static struct PyMethodDef PyEthModuleMethods[] = {
-    { "scan",
-        (PyCFunction) scan, METH_VARARGS,
-        "Perform a scan for access points in the area. \
-\n\nArguments:\
-\n  - device to use for scanning on (e.g. eth1, wlan0)." },
-
-    { NULL, NULL, 0, NULL } /* sentinel */
-};
-
-#if PY_MAJOR_VERSION >= 3 /* Python 3 */
-
-static struct PyModuleDef iwlist = {
-        PyModuleDef_HEAD_INIT,
-        "iwlist",
-        NULL, /* Documentation */
-        -1,
-        PyEthModuleMethods
-};
-
-PyMODINIT_FUNC
-PyInit_iwlist(void) {
-    return PyModule_Create(&iwlist);
-}
-
-#else /* Python 2 */
-
-void
-initiwlist(void) {
-    PyObject *m;
-
-    m = Py_InitModule("iwlist", PyEthModuleMethods);
-    PyModule_GetDict(m);
-}
-
-#endif
diff --git a/iwlib/iwlist.py b/iwlib/iwlist.py
new file mode 100644
index 0000000..53d2759
--- /dev/null
+++ b/iwlib/iwlist.py
@@ -0,0 +1,74 @@
+# Copyright (C) 2009-2012 Red Hat, Inc.
+# Copyright (C) 2013-2014 Nathan Hoad.
+#
+# Interface with iwlib by Nathan Hoad <nathan@getoffmalawn.com>.
+#
+# This application is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License as published by the Free
+# Software Foundation; version 2.
+#
+# This application is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+# General Public License for more details.
+
+import os
+
+from .utils import _get_range_info, _parse_stats, _get_bytes, iwlib_socket
+from ._iwlib import ffi, lib as iwlib
+
+
+def scan(interface):
+    """Perform a scan for access points in the area.
+
+    Arguments:
+        interface - device to use for scanning (e.g. eth1, wlan0).
+    """
+    interface = _get_bytes(interface)
+
+    head = ffi.new('wireless_scan_head *')
+
+    with iwlib_socket() as sock:
+        range = _get_range_info(interface, sock=sock)
+
+        if iwlib.iw_scan(sock, interface, range.we_version_compiled, head) != 0:
+            errno = ffi.errno
+            strerror = "Error while scanning: %s" % os.strerror(errno)
+            raise OSError(errno, strerror)
+
+    results = []
+
+    scan = head.result
+
+    buf = ffi.new('char []', 1024)
+
+    while scan != ffi.NULL:
+        parsed_scan = {}
+
+        if scan.b.has_mode:
+            parsed_scan[b'Mode'] = ffi.string(iwlib.iw_operation_mode[scan.b.mode])
+
+        if scan.b.essid_on:
+            parsed_scan[b'ESSID'] = ffi.string(scan.b.essid)
+        else:
+            parsed_scan[b'ESSID'] = b'Auto'
+
+        if scan.has_ap_addr:
+            iwlib.iw_ether_ntop(
+                ffi.cast('struct ether_addr *', scan.ap_addr.sa_data), buf)
+            if scan.b.has_mode and scan.b.mode == iwlib.IW_MODE_ADHOC:
+                parsed_scan[b'Cell'] = ffi.string(buf)
+            else:
+                parsed_scan[b'Access Point'] = ffi.string(buf)
+
+        if scan.has_maxbitrate:
+            iwlib.iw_print_bitrate(buf, len(buf), scan.maxbitrate.value)
+            parsed_scan[b'BitRate'] = ffi.string(buf)
+
+        if scan.has_stats:
+            parsed_scan[b'stats'] = _parse_stats(scan.stats)
+
+        results.append(parsed_scan)
+        scan = scan.next
+
+    return results
diff --git a/iwlib/utils.c b/iwlib/utils.c
deleted file mode 100644
index dc8aac1..0000000
--- a/iwlib/utils.c
+++ /dev/null
@@ -1,231 +0,0 @@
-/*
- * Copyright (C) 2009-2012 Red Hat, Inc.
- * Copyright (C) 2013 Nathan Hoad.
- *
- * Interface with iwlib by Nathan Hoad <nathan@getoffmalawn.com>.
- *
- * This application is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License as published by the Free
- * Software Foundation; version 2.
- *
- * This application is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- */
-
-#include "utils.h"
-
-PyObject*
-wireless_config_to_PyDict(struct wireless_config *basic)
-{
-    char buffer[1024];
-    PyObject *dict;
-
-    if ((dict = PyDict_New()) == NULL)
-        return NULL;
-
-    if (basic->has_mode)
-        SAFE_SETITEMSTRING(dict, "Mode", PY_FROMSTRING(iw_operation_mode[basic->mode]));
-
-    if (basic->essid_on) {
-        SAFE_SETITEMSTRING(dict, "ESSID", PY_FROMSTRING(basic->essid));
-    } else {
-        SAFE_SETITEMSTRING(dict, "ESSID", PY_FROMSTRING("Auto"));
-    }
-
-    if (basic->has_nwid) {
-        if(basic->nwid.disabled) {
-            SAFE_SETITEMSTRING(dict, "NWID", PY_FROMSTRING("Auto"));
-        } else {
-            SAFE_SETITEMSTRING(dict, "NWID",
-                PY_FROMFORMAT("%X", basic->nwid.value));
-        }
-    }
-
-    if(basic->has_freq) {
-        iw_print_freq_value(buffer, sizeof(buffer), basic->freq);
-        SAFE_SETITEMSTRING(dict, "Frequency", PY_FROMSTRING(buffer));
-    }
-
-    /* FIXME: This is known to be incorrect for wireless_scan structs. */
-    if(basic->has_key) {
-        if((basic->key_flags & IW_ENCODE_DISABLED) || (basic->key_size == 0)) {
-            SAFE_SETITEMSTRING(dict, "Key", PY_FROMSTRING("off"));
-        } else {
-            iw_print_key(buffer, sizeof(buffer), basic->key, basic->key_size, basic->key_flags);
-            SAFE_SETITEMSTRING(dict, "Key", PY_FROMSTRING(buffer));
-        }
-    }
-    return dict;
-}
-
-void
-add_wireless_stats_toPyDict(iwstats *stats, PyObject *dict) {
-    PyObject *quality;
-
-    if (!dict || !stats) {
-        return;
-    }
-
-    if ((quality = PyDict_New()) == NULL)
-        return;
-
-    SAFE_SETITEMSTRING(quality, "quality", Py_BuildValue("i", stats->qual.qual));
-    SAFE_SETITEMSTRING(quality, "level", Py_BuildValue("i", stats->qual.level));
-    SAFE_SETITEMSTRING(quality, "noise", Py_BuildValue("i", stats->qual.noise));
-    SAFE_SETITEMSTRING(quality, "updated", Py_BuildValue("i", stats->qual.updated));
-
-    SAFE_SETITEMSTRING(dict, "stats", quality);
-}
-
-PyObject*
-wireless_info_to_PyDict(struct wireless_info *info)
-{
-    char buffer[1024];
-    PyObject *dict = wireless_config_to_PyDict(&info->b);
-
-    if(info->has_ap_addr) {
-        iw_ether_ntop((struct ether_addr *)info->ap_addr.sa_data, buffer);
-        if((info->b.has_mode) && (info->b.mode == IW_MODE_ADHOC))
-            SAFE_SETITEMSTRING(dict, "Cell", PY_FROMSTRING(buffer));
-        else
-            SAFE_SETITEMSTRING(dict, "Access Point", PY_FROMSTRING(buffer));
-    }
-
-    if(info->has_bitrate) {
-        iw_print_bitrate(buffer, sizeof(buffer), info->bitrate.value);
-        SAFE_SETITEMSTRING(dict, "BitRate", PY_FROMSTRING(buffer));
-    }
-
-    if (info->has_stats) {
-        add_wireless_stats_toPyDict(&info->stats, dict);
-    }
-
-    return dict;
-}
-
-PyObject*
-wireless_scan_to_PyDict(struct wireless_scan *scan)
-{
-    char buffer[1024];
-    PyObject *dict;
-
-    if ((dict = wireless_config_to_PyDict(&scan->b)) == NULL)
-        return NULL;
-
-    if(scan->has_ap_addr) {
-        iw_ether_ntop((struct ether_addr *)scan->ap_addr.sa_data, buffer);
-        if((scan->b.has_mode) && (scan->b.mode == IW_MODE_ADHOC))
-            SAFE_SETITEMSTRING(dict, "Cell", PY_FROMSTRING(buffer));
-        else
-            SAFE_SETITEMSTRING(dict, "Access Point", PY_FROMSTRING(buffer));
-    }
-
-    if(scan->has_maxbitrate) {
-        iw_print_bitrate(buffer, sizeof(buffer), scan->maxbitrate.value);
-        SAFE_SETITEMSTRING(dict, "BitRate", PY_FROMSTRING(buffer));
-    }
-
-    if (scan->has_stats) {
-        add_wireless_stats_toPyDict(&scan->stats, dict);
-    }
-
-    return dict;
-}
-
-/* XXX All functions below are exported to iwlib.utils */
-
-PyObject *
-get_max_quality(PyObject *self, PyObject *args)
-{
-    const char *devname;
-    char buffer[1024];
-    int has_range;
-    int sock;
-    struct iw_range range;
-
-    if (!PyArg_ParseTuple(args, "s", &devname)) {
-        return NULL;
-    }
-
-    OPEN_IW(sock);
-
-    has_range = (iw_get_range_info(sock, devname, &range) >= 0);
-
-    if((!has_range) || (range.we_version_compiled < 14)) {
-        sprintf(buffer, "'%s' Interface doesn't support scanning", devname);
-        PyErr_SetString(PyExc_OSError, buffer);
-        return NULL;
-    }
-
-    iw_sockets_close(sock);
-    return Py_BuildValue("i", range.max_qual.qual);
-}
-
-PyObject *
-supports_scanning(PyObject *self, PyObject *args)
-{
-    const char *devname;
-    int has_range;
-    int sock;
-    struct iw_range range;
-    PyObject *res;
-
-    if (!PyArg_ParseTuple(args, "s", &devname)) {
-        return NULL;
-    }
-
-    OPEN_IW(sock);
-
-    has_range = (iw_get_range_info(sock, devname, &range) >= 0);
-    iw_sockets_close(sock);
-
-    if((!has_range) || (range.we_version_compiled < 14)) {
-        res = Py_False;
-    } else {
-        res = Py_True;
-    }
-
-    Py_INCREF(res);
-    return res;
-}
-
-static struct PyMethodDef PyEthModuleMethods[] = {
-    { "get_max_quality",
-        (PyCFunction) get_max_quality, METH_VARARGS,
-        "Return max quality of an interface. Useful for \
-\n\nworking out percentages of quality results from \
-\niwconfig.scan" },
-    { "supports_scanning",
-        (PyCFunction) supports_scanning, METH_VARARGS,
-        "Check if an interface supports scanning. \
-\n\nReturns true if the device supports scanning, False otherwise." },
-    { NULL, NULL, 0, NULL } /* sentinel */
-};
-
-#if PY_MAJOR_VERSION >= 3 /* Python 3 */
-
-static struct PyModuleDef utilsmodule = {
-        PyModuleDef_HEAD_INIT,
-        "utils",
-        NULL, /* Documentation */
-        -1,
-        PyEthModuleMethods
-};
-
-PyMODINIT_FUNC
-PyInit_utils(void) {
-    return PyModule_Create(&utilsmodule);
-}
-
-#else /* Python2 */
-
-void
-initutils(void) {
-    PyObject *m;
-    m = Py_InitModule("utils", PyEthModuleMethods);
-    PyModule_GetDict(m);
-}
-
-#endif
diff --git a/iwlib/utils.h b/iwlib/utils.h
deleted file mode 100644
index fc37ea2..0000000
--- a/iwlib/utils.h
+++ /dev/null
@@ -1,34 +0,0 @@
-#include <Python.h>
-#include <iwlib.h>
-
-#define OPEN_IW(sock) { \
-        char _buf[1024]; \
-        if((sock = iw_sockets_open()) < 0) { \
-            snprintf(_buf, 1024, "Error opening iwlib socket [Errno %d] %s", errno, strerror(errno)); \
-            PyErr_SetString(PyExc_OSError, _buf); \
-            return NULL; \
-        } \
-    }
-
-#define SAFE_SETITEMSTRING(dict, key, value) do { \
-    PyObject *__tmp; \
-    __tmp = value; \
-    if (__tmp) \
-        PyDict_SetItemString(dict, key, __tmp); \
-} while(0)
-
-
-PyObject *wireless_info_to_PyDict(struct wireless_info *info);
-PyObject *wireless_config_to_PyDict(struct wireless_config *info);
-PyObject *wireless_scan_to_PyDict(struct wireless_scan *scan);
-
-
-/* Python 2/3 compatibility helpers **********************************/
-
-#if PY_MAJOR_VERSION >= 3
-#define PY_FROMSTRING(X) PyBytes_FromString( (X) )
-#define PY_FROMFORMAT(X, Y) PyBytes_FromFormat( (X), (Y) )
-#else
-#define PY_FROMSTRING(X) PyString_FromString( (X) )
-#define PY_FROMFORMAT(X, Y) PyString_FromFormat( (X), (Y) )
-#endif
diff --git a/iwlib/utils.py b/iwlib/utils.py
new file mode 100644
index 0000000..eae2bf4
--- /dev/null
+++ b/iwlib/utils.py
@@ -0,0 +1,87 @@
+# Copyright (C) 2009-2012 Red Hat, Inc.
+# Copyright (C) 2013-2014 Nathan Hoad.
+#
+# Interface with iwlib by Nathan Hoad <nathan@getoffmalawn.com>.
+#
+# This application is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License as published by the Free
+# Software Foundation; version 2.
+#
+# This application is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+# General Public License for more details.
+
+import contextlib
+import errno
+import os
+
+from ._iwlib import ffi, lib as iwlib
+
+
+@contextlib.contextmanager
+def iwlib_socket(sock=None):
+    if sock is None:
+        closing = True
+        sock = iwlib.iw_sockets_open()
+    else:
+        closing = False
+
+    if sock < 0:
+        raise OSError(ffi.errno, os.strerror(ffi.errno))
+
+    try:
+        yield sock
+    finally:
+        if closing:
+            iwlib.iw_sockets_close(sock)
+
+
+def get_max_quality(interface):
+    """
+    Return max quality of an interface. Useful for working out percentages of
+    quality results from `iwconfig.scan()`.
+    """
+    range = _get_range_info(interface)
+    return range.max_qual.qual
+
+
+def supports_scanning(interface):
+    """
+    Check if an interface supports scanning.
+    Returns true if the device supports scanning. False otherwise.
+    """
+    try:
+        _get_range_info(interface)
+    except OSError:
+        return False
+    else:
+        return True
+
+
+def _get_range_info(interface, sock=None):
+    interface = _get_bytes(interface)
+    range = ffi.new('struct iw_range *')
+
+    with iwlib_socket(sock=sock) as sock:
+        has_range = iwlib.iw_get_range_info(sock, interface, range) >= 0
+
+    if not has_range or range.we_version_compiled < 14:
+        err = errno.ENOTSUP
+        raise OSError(err, os.strerror(err))
+    return range
+
+
+def _parse_stats(stats):
+    return {
+        b'quality': stats.qual.qual,
+        b'level': stats.qual.level,
+        b'noise': stats.qual.noise,
+        b'updated': stats.qual.updated,
+    }
+
+
+def _get_bytes(s):
+    if isinstance(s, bytes):
+        return s
+    return s.encode('utf8')
diff --git a/setup.py b/setup.py
index 76cc7cc..71664d4 100644
--- a/setup.py
+++ b/setup.py
@@ -3,10 +3,7 @@
 import os
 import sys
 
-try:
-    from distutils.core import setup, Extension, find_packages
-except ImportError:
-    from setuptools import setup, Extension, find_packages
+from setuptools import setup
 
 # Publish Helper.
 if sys.argv[-1] == 'publish':
@@ -14,22 +11,13 @@ if sys.argv[-1] == 'publish':
     sys.exit()
 
 include_dirs = ['iwlib']
-libraries = ["iw"]
 
-ext_modules = [
-    Extension("iwlib.iwconfig", sources=['iwlib/utils.c', 'iwlib/iwconfig.c'],
-              include_dirs=include_dirs, libraries=libraries),
-
-    Extension("iwlib.iwlist", sources=['iwlib/iwlist.c', 'iwlib/utils.c'],
-              include_dirs=include_dirs, libraries=libraries),
-
-    Extension("iwlib.utils", sources=['iwlib/utils.c'],
-              include_dirs=include_dirs, libraries=libraries),
-]
+dependencies = ['cffi>=1.0.0']
+cffi_modules = ['iwlib/_iwlib_build.py:ffibuilder']
 
 settings = {
     'name': 'iwlib',
-    'version': '1.5',
+    'version': '1.6',
     'description': "Python module to interface with iwlib",
     'long_description': open('README.rst').read(),
     'author': 'Nathan Hoad',
@@ -42,11 +30,16 @@ settings = {
         'Natural Language :: English',
         'License :: OSI Approved :: GNU General Public License v2 (GPLv2)',
         'Programming Language :: Python',
+        'Programming Language :: Python :: 2.6',
         'Programming Language :: Python :: 2.7',
         'Programming Language :: Python :: 3',
+        'Programming Language :: Python :: PyPy',
     ),
-    'ext_modules': ext_modules,
-    'packages': find_packages(),
+    'zip_safe': False,
+    'packages': ['iwlib'],
+    'install_requires': dependencies,
+    'setup_requires': dependencies,
+    'cffi_modules': cffi_modules,
 }
 
 setup(**settings)
diff --git a/test/__init__.py b/test/__init__.py
new file mode 100644
index 0000000..e69de29
